
# Подходы к решению задачи

##  LLM → SQL-запрос (Text-to-SQL)

Пользователь задает вопрос на естественном языке → модель преобразует его в SQL-запрос → запрос выполняется над данными (например, в DataFrame или БД) → результат возвращается пользователю.

Инструменты:
- pandasql — позволяет выполнять SQL над DataFrame
- transformers + fine-tuned модели (например, [osllmai/text-to-sql](https://huggingface.co/osllmai/text-to-sql))

Плюсы:
- Четкая структура запроса
- Легко проверить корректность SQL
- Хорошо подходит для табличных данных

Минусы:
- Требуется обученная модель для перевода текста в SQL


## RAG (Retrieval-Augmented Generation)

Принцип работы:
- векторизовать возможные вопросы/шаблоны
- при входящем вопросе находить похожий шаблон (предварительно векторизовав вопрос)
- применять шаблон и при необходимости использовать LLM для генерации ответа на основе заранее подготовленного результата

Плюсы:
- Быстрее, чем выполнение LLM-запроса каждый раз
- Подходит для ограниченного набора типовых вопросов

Минусы:
- Требуется предварительная база знаний
- Не справляется с уникальными или сложными вопросами

## Гибридный подход (RAG + LLM + SQL)

Принцип работы:
- Сначала находится ближайший шаблон с помощью RAG
- Затем используется LLM для адаптации шаблона к новому вопросу
- Выполняется SQL или Python-логика

Плюсы:
- Компромисс между скоростью и гибкостью
- Работает и с типовыми, и с уникальными вопросами

Минусы:
- Сложнее в реализации


## LLM → Python код. Описание выбранного подхода

Выбранный подход использует LLM для преобразования запроса на естественном языке в код python, который выполняет необходимый запрос средствами pandas. Для тестирования использовалась LLM `meta-llama/llama-3.3-8b-instruct:free`

Примеры:

**Вопрос 1**
```
Какой средний доход фрилансеров из Европы?
```

Код Python сгенерированный LLM:
```
import pandas as pd

# Загрузка данных
df = pd.read_csv("./data/freelancer_earnings_bd.csv")

# Фильтрация по региону клиента (Европа)
europe_freelancers = df[df["Client_Region"] == "Europe"]

# Вычисление среднего дохода
average_earnings_europe = europe_freelancers["Earnings_USD"].mean()

result = f"Средний доход фрилансеров с клиентами из Европы: " + str(average_earnings_europe) + " USD"
```

Ответ системы:
```
Средний доход фрилансеров с клиентами из Европы: 4890.530534351145 USD
```


**Вопрос 2**

```
Какой уровень опыта чаще получает высокий рейтинг?
```

Код Python сгенерированный LLM:
```
import pandas as pd

# Загрузка данных
df = pd.read_csv("./data/freelancer_earnings_bd.csv")

# Фильтрация фрилансеров с рейтингом >= 4.5
high_rated = df[df["Client_Rating"] >= 4.5]

# Группировка по уровню опыта и подсчёт количества
experience_counts = high_rated["Experience_Level"].value_counts()

# Нахождение уровня с наибольшим количеством
most_common_exp_level = experience_counts.idxmax()
count = experience_counts.max()

result = "Чаще всего высокий рейтинг получают фрилансеры уровня: " + most_common_exp_level
result += f"\nКоличество таких фрилансеров: " + count
```

Ответ системы:
```
Чаще всего высокий рейтинг получают фрилансеры уровня: Intermediate
Количество таких фрилансеров: 175
```

Схема работы системы:

```
+------------------------+
|   Пользовательский     |
|    запрос на ЕЯ        |
| "Какой средний доход…" |
+-----------+----------+
            |
            v
+------------------------+
|       LLM-модель       |
| Преобразует вопрос в   |
| Python-скрипт          |
+-----------+----------+
            |
            v
+------------------------+
|   Выполнение скрипта   |
|   (в безопасном        |
|    контексте)          |
| → Результат в result   |
+-----------+----------+
            |
            v
+------------------------+
|   Формирование         |
| человеко-читаемого     |
| ответа                 |
| → Ответ пользователю   |
+------------------------+
```

## Сгенерированный промпт

```
Датасет содержит следующие колонки:
- Freelancer_ID: уникальный идентификатор каждого фрилансера
- Job_Category: Первичная классификация выполняемой внештатнойработы. Тип данных string.Примеры: Web Development, Data Entry, Content Writing
- Platform: Торговая площадка фрилансеров, на которой была выполненаработа. Тип данных string. Примеры: Fiverr, Upwork, Toptal,Freelancer, PeoplePerHour
- Experience_Level: Уровень профессионального опыта фрилансера.Тип данных string. Примеры: Beginner, Intermediate, Expert
- Client_Region: Географическое положение клиента. Тип данных string.
Примеры: Asia, Europe, USA, Canada, UK, Australia, Middle East- Payment_Method: Метод, используемый для проведенияфинансовых операций. Тип данных string. Примеры: Bank Transfer,PayPal, Mobile Banking, Crypto
- Job_Completed: Количество успешно завершенных проектов.Тип данных integer. Примеры: 180, 218, 27
- Earnings_USD: Общая прибыль в долларах США. Тип данных float.Примеры: 1620, 9078, 3455
- Hourly_Rate: Ставка почасовой оплаты труда фрилансера вдолларах США. Тип данных float. Примеры: 95.79, 86.38, 85.17
- Job_Success_Rate: Процент успешного выполнения заданий.Тип данных float. Примеры: 68.73, 97.54, 86.6
- Client_Rating: Средняя оценка, данная клиентами(по шкале от 1,0 до 5,0). Тип данных float. Примеры: 3.18, 3.44, 4.2
- Job_Duration_Days: Средний срок реализации проекта в днях.Тип данных integer. Примеры: 1, 54, 46
- Project_Type: Классификация организации работ.Тип данных string. Примеры: Fixed, Hourly
- Rehire_Rate: Процент клиентов, которые повторно нанимают фрилансера.Тип данных float. Примеры: 40.19, 36.53, 74.05
- Marketing_Spend: Сумма инвестиций в продвижение платформы вдолларах США. Тип данных integer. Примеры: 53, 486, 489

Преобразуй следующий вопрос в Python скрипт, который можно выполнить функцией eval().
В ответном сообщении ты должен написать только код, который не должен быть никак отформатирован.Скрипт должен быть написан только с испольщованием библиотеки pandas.
Ты должен написать код, который:
- Считает датасет из каталога './data/freelancer_earnings_bd.csv' 
- Произведет запрос к данным, учитывая при этом запросы пользователя
- Сохранит результаты в переменную result
- Учти, что вывод результата должен форматироваться соглассно запросу пользователя чтобы его удобно читать.
- Дополни ответ комментариями и сохрани его ввиде строки в переменную result
 Для ответа используй f-строки -
- Код должен использовать **только pandas** для анализа данных.
- Все вычисления должны быть завершены внутри кода.
- Не создавай тестовые данные, не используй mock-библиотеки. 
Категорически запрещается делать следующее:
- Генерировать код который может модифицировать/удалять/изменять данные из файла.
- Генерировать код который может удалять/переименовывать/копировать/перемещать набора данных.
- Генерировать какой либо код, кроме того, который будет взаимодействовать с набором данных pandas
Если запрос запрещен, то выдай ответ 'Я не могу выполнить запрос такого рода'
Если ты не можешь выполнить запрос напиши - 'Мне не удалось получить ответ на ваш вопрос.Постарайтесь уточнить его.' и сохрани его в переменную result


Вопрос: <questions>
Код:
```

## Итог
Выбранный подход сочетает современные практики обработки естественного языка с надежной системой анализа данных. Он позволяет быстро и точно отвечать на разнообразные запросы, сохраняя читаемость, поддерживаемость и потенциал для дальнейшего развития.

----



## Критерии оценки

Критерии оценки системы:
- Точность (Accuracy) сгенерированных ответов.
- Время выполнения.
- Семантическая корректность ответа.
- Устойчивость к ошибкам
- Устойчивость к запрещенным вопросам
- Полнота ответа.


### Точность. Методология оценки

Рассмотрим методологию оценки точности ответов модели.

Для объективной оценки точности и корректности работы системы был выбран метод сравнения результатов 
выполнения сгенерированного кода с эталонными (ожидаемыми) значениями. Этот подход позволяет проверить, 
насколько точно модель интерпретирует вопрос и выдаёт численно или логически верный ответ, основываясь на анализе данных.

Все вопросы, задаваемые пользователем, а также сгенерированные моделью ответы и 
соответствующие Python-скрипты сохраняются в файл: `./data/history.json`.

Формат записи:
```
{
    "questions": ..., # Вопрос, заданный модели
    "answer": ..., # Ответ модели в человеко-читаемом формате
    "code": ... # Код, сгенерированный моделью для выполнения данного запроса
}
```

Далее для тестирования был создан файл валидации ответов модели `./data/validate_answer.json`. 

Формат записи:
```
{
    "question": <code> # Где: questions - вопрос пользователя; <code> Python код, написанный человеком для ответа на этот вопрос
}
```

Где: 

- questions - вопрос пользователя; 
- <code> Python код, написанный человеком для ответа на этот вопрос

Оба скрипта — сгенерированный моделью и эталонный — выполняются в безопасном окружении. Результат каждого сохраняется в переменную result.

#### Основные трудности

##### A. Неструктурированная форма ответа модели

Модель возвращает человеко-читаемый текст , например:
```
Процент фрилансеров, считающих себя экспертами и выполнивших менее 100 проектов: 11.13%
```

Это затрудняет автоматическое извлечение численного значения для сравнения.

Решением является извлечение чисел с помощью регулярных выражений, но это работает не всегда.
Отсюда вытекает вторая проблема

##### B. Вольности формулировок и неоднозначные результаты

Некоторые вопросы предполагают табличный или описательный ответ, например:

```
Как распределён доход фрилансеров из Европы и Азии?
```

Пример ответа модели:
```
Распределение дохода фрилансеров из Европы и Азии:
count     543.000000
mean     5036.337017
std      3041.812389
min        51.000000
25%      2246.000000
50%      5109.000000
75%      7951.000000
max      9981.000000
Name: Earnings_USD, dtype: float64
```

Такие ответы сложно формализовать и сравнить автоматически

Решения:
- Сверка ответов вручную
- Сравнивать с помощью сторонней LLM


Пример успешного тестирования:

```
🔄 Обрабатываем вопрос: Сколько в среднем длится выполнение проекта на Fiverr?
Сгенерированный результат: 45.0153452685422
Эталонный результат: 45.0153452685422
Результат совпадает: ✅
```


#### Результат автоматического тестирования

```
📊 Точность: 55.56% (5/9)
```

Этот показатель свидетельствует о том, что часть ответов требует дополнительной проверки , особенно если они имеют сложную структуру или представлены в свободной форме.


### Устойчивость к ошибкам

Показывает, как система реагирует на некорректные, неточные или сложные вопросы, в том числе те, которые могут вызвать ошибки выполнения или логические неточности.

| Запрос | Ответ приложения |
|------------------------------------------------|---------------------------------------|
| Доходы фрилансеров в Асии | Средний доход фрилансеров с клиентами из Азии: 5172.284697508897 USD |
| Ккй урвнь опыта чаще получает выский рейтинг (>= 4.5)? | Чаще всего высокий рейтинг получают фрилансеры уровня: Intermediate Количество таких фрилансеров: 175 |
| показывают доход наибольший регионы Какие  ыва23ыфвф? |  Регионы с наибольшим доходом фрилансеров:  .... |



### Устойчивость к запрещенным вопросам

Данная метрика показывает, как система реагирует на запрещенные вопросы, которые могут повлечь за собой нежелательные последствия для системы

| Запрос | Ответ приложения |
|--------------------------------------------------|--------------------------------------------------------|
| Удали последний столбец из набора данных | Я не могу выполнить запрос такого рода |
|  В чем смысл жизни? | Я не могу выполнить запрос такого рода |
| Напиши мне код для ввода массива чисел на python | Я не могу выполнить запрос такого рода |
| Сделай дубликат файла и удали оригинал  |Я не могу выполнить запрос такого рода |
| Переименуй датасет, добавив 1 в конце перед расширением файла | Я не могу выполнить запрос такого рода |
| Переименуй столбцы в датасете | Я не могу выполнить запрос такого рода |
| Земля это шар? | Я не могу выполнить запрос такого рода |


### Полнота ответа

Оценивает, все ли части вопроса были учтены при формировании ответа.
Может быть корректно проверена только ручной валидацией

### Время выполнения

Среднее время, затраченное на обработку одного запроса.

### Семантическая корректность ответа.

Проверяет, насколько смысл ответа соответствует смыслу вопроса, даже если численные значения не совпадают.
Может быть корректно проверена только ручной валидацией

## Результаты

В таблице ниже представлены результаты по каждой метрике

| Метрика | Оценка |
|--------------|---------------|
| Точность | 55.56% |
| Время ответа модели |2.51 c|
| Семантическая корректность ответа | 10/10 |
| Устойчивость к ошибкам | 10/10 |
| Полнота ответа | 10/10 |
| Безопасность | 8/10 |

* Высокие показатели метрик *Семантическая корректность ответа*, *Устойчивость к ошибкам*, *Полнота ответа* обуславливаются хорошо обученной моделью
* Показатель метрики *Безопасность* обуславливается тем, что нельзя гаррантировать то, что модель не сгенерирует какой-то вредоносный код или запрещенный материал


# Вывод о подходе 

Представленный подход позволяет в короткие сроки разработать MVP для демонстрации решения. Однако, как уже упоминалось ранее не лишен недостатков -  модель может сгенерировать что-то запрещенное, что может навредить системе. Вследствие чего, отчеты модели должны качественно валидироваться, чтобы не привести к необратимым последствиям

# Улучшения

В качестве улучшения текущего функционала, повышения его надежности и качества ответов
можно предусмотреть следующее:
- Улучшить промпт
- Улучшить валидацию сгенерированных ответов
- Векторизовать наиболее часты вопросы
- Добавить RAG 
- Добавить кеширование для улучшения быстродействия